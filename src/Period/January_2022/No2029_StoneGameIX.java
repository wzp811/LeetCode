package Period.January_2022;

public class No2029_StoneGameIX {
    public boolean stoneGameIX(int []stones){
        int []count = new int[3];
        for(int i=0;i<3;i++) count[i] = 0;
        for(int i=0;i<stones.length;i++) count[stones[i]%3]++;
        return count[0]%2==0?(count[1]==0||count[2]==0?false:true):(Math.abs(count[1]-count[2])>2?true:false);
    }
}


//0为偶数的情况下，0不起影响。那么A先手，就能决定在整个过程中B只能移除一个类型的子。
//A先手的子就是B整个过程中唯一能移除的石头，所以A先拿不是最多的那种，B整个过程就只能拿这一种。
//所以如果不是最多的那种个数不是0的话，A就胜；否则A就败。
//  1   1   2   1   2   1   2
//  2   2   1   2   1   2   1
//0为奇数的情况下，会对整个序列造成影响。
//相当于有一次换手机会，看谁在什么时间点用。
//1和2的数量差不超过2的情况下，A首先不可能第一次就0，相当于把先手机会给B，B只需要按照上面A的策略就赢了。
//然而A先手拿1或2，B只需要拿0，相当于A给B设的局限回到自己身上来了，B必胜。
//上面可能在考虑一种情况，就比如1比2少，从上面看来谁在循环中是1谁就输咯？
//那A先拿2，B如果0的话，A还是2，在循环中也是2，A是不是就赢了？
//并不，因为1比2少不超过2个。相等的情况不用说，A肯定输。
//假如1比2少一个，A先2，B直接0。下面又是A2，B1，A2，B1。最后全拿完A输。A先1的话，B直接0，A1，B2，1更快完，A还是输。
//假如1比2少两个，A先2，B直接0。A2，B1，A2，B1。。。最后剩一个2，A2，全拿完，A输。
//
//但是如果1比2少超过两个，A先拿2，B如果跟着2，A直接0换手，B下面是1，1先完，得被迫拿2，所以B输。
//A先拿2，B用0换手，A2，B1，A2，B1，最后会多出两个2，A2之后B只能2，所以B输。
//A先拿1，B直接0换手A就输了。
//所以0为奇数的时候，如果1比2少超过两个，A胜，否则B胜。


